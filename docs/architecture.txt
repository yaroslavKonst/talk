Encryption system
-----------------
Low level protocol. It is used on top of TCP connection.

Data consist of blocks. Each block is transmitted as a
sequene of segments and belongs to a stream.

Data block structure.
| stream id (byte) | data block size (uint64) | segment sequence |

Segment sequence structure.
| stream id (byte) | segment 1 size (uint32) | segment 1 data | ...
	| stream id (byte) | segment n size (uint32) | segment n data |

Segments of one stream can be sent between segments of
another stream. So streams are used for channel multiplexing.

Streams with lower id have higher priority than streams with
higher id. Priority is taken into account when multiple streams
have segments ready to be sent. In this case a ready stream
with the highest priority is chosen.

Encryption protocol. It works on top of low level protocol.
Each stream has separate session keys.
Encrypted block structure:
| mac | nonce | message |

Encrypted blocks are sent scrambled.
Scrambled block structure:
| scrambler init (1 byte) | data |

Signed block structure:
| data | signature |

Timestamps are 64-bit signed integers that contain number of
seconds since the Epoch, 1970.01.01 00:00:00 UTC.

Handshake occurs when client connects the server. It is done using
the stream with id 0.
During handshake client and server authenticate each other
and establish encrypted connection.

Server                                               Client
   |        <----------------------------------        |
   |              signed, then scrambled               |
   |        | client public key | timestamp 1 |        |
   |                                                   |
   |        ---------------------------------->        |
   |                     encrypted                     |
   |        | server public key | timestamp 2 |        |
   |                                                   |
   |        <----------------------------------        |
   |                     encrypted                     |
   |                  | timestamp 2 |                  |

Keep alive messages are sent periodically by the client to
check whether the connection is still in active state.
Server sends response upon receiving client's request.

Server                                               Client
   |        <----------------------------------        |
   |                     encrypted                     |
   |                  | timestamp 1 |                  |
   |                                                   |
   |        ---------------------------------->        |
   |                     encrypted                     |
   |                  | timestamp 1 |                  |

Control system
--------------
Control system does not use encryption and authentication because
control port is available only via UNIX socket and is not exposed
to the network.

Command structure:
  Command id (int32)   Command data
|      shutdown      |
|   get public key   |
|      add user      | key | signature | name size (int32) | name |
|    remove user     | key |
|     list users     |
|   list banned IP   |
|       ban IP       | IP (uint32) |
|      unban IP      | IP (uint32) |

Response structure.
shutdown         | no response
get public key   | result code | public key |
add user         | result code |
remove user      | result code |
list users       | result code | user count (int32) | key | name (55 bytes) |...
list banned IP   | result code | IP 1 (uint32) | ... | IP N (uint32) |
ban IP           | result code |
unban IP         | result code |

Message system
--------------
Message system uses encrypted data blocks during messasge delivery.
Message content is additionally encrypted using one time session keys
generated by sender and receiver for end to end encryption.

Message structure:
| sender key | receiver key | timestamp | index (int32) | encrypted data |
All unencrypted fields are signed.

Index field is used to distinguish messages sent during one second and
thus having the same timestamps.

Commands from client to server.
  command (int32)
|   keep alive    | timestamp |
|  text message   | message |
|   list users    |
|  get messages   | timestamp |
|   voice init    | peer key | timestamp |
|    voice end    |
|   voice data    | voice block |

Response
keep live    | command id | timestamp |
text message | command id | status (int32) |
list users   | command id | user count (int32) | key | name (55 bytes) |...
get messages | no response
voice init   | command id | status (int32) |
voice end    | no response
voice data   | no response

Commands from server to client.
| deliver message | message |
|  voice request  | peer key | timestamp |
|    voice end    |
|   voice data    | voice block |

     response
deliver message | no response
voice request   | command id | status (int32) |
voice end       | no response
voice data      | no response

Storage structure
-----------------
Files containing message data blocks.
/owner_key/storage/peer_key/index - index for fast search
/owner_key/storage/peer_key/in/timestamp_index - incoming message
/owner_key/storage/peer_key/out/timestamp_index - outgoing message

Message attributes.
/owner_key/attributes/peer_key/timestamp_index_{s,r}
Each file contains flags. If the file does not exist it means that all
flags are cleared.
Flag list: unread, unsent, fault.
unread: incoming message that has not been marked as read.
unsent: outgoing message that has not been sent.
fault: outgoing message that will not be sent due to permanent error
(invalid user keys etc.).

Contact book.
/owner_key/contacts/peer_key
Each file contains user name.

Configuration
-------------
Server configuration.
talkd.conf in ini format.
RestrictedMode

[Network]
IPv4
Port

[FailBan]
Enabled
AllowedTries
CooldownInterval

Client configuration.
/owner_key/talk.conf in ini format.
[connection]
ServerIP
ServerPort
ServerKey

[voice]
Volume
ApplyFilter
SilenceLevel
